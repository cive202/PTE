<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PTE Scoring Engine - Data Collection</title>
    <style>
        body { font-family: sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; }
        textarea { width: 100%; height: 100px; margin-bottom: 1rem; }
        .controls { margin-bottom: 1rem; }
        button { padding: 0.5rem 1rem; cursor: pointer; }
        #status { margin-top: 1rem; color: #666; }
        .word { padding: 2px 4px; border-radius: 3px; display: inline-block; margin: 2px; }
        .correct { background-color: #d4edda; color: #155724; }
        .wrong { background-color: #f8d7da; color: #721c24; }
        .stress-error { background-color: #fff3cd; color: #856404; border-bottom: 2px solid orange; }
    </style>
</head>
<body>
    <h1>PTE Data Collection & Validation</h1>
    
    <div>
        <h3>Reference Text</h3>
        <textarea id="ref-text" placeholder="Enter text here...">Over the years, it got easier to build such software, even for non-technical folk.</textarea>
    </div>

    <div class="controls">
        <button id="btn-record">Record</button>
        <button id="btn-stop" disabled>Stop</button>
        <span id="recording-indicator" style="display:none; color: red;">ðŸ”´ Recording...</span>
    </div>

    <div class="controls">
        <button id="btn-save" disabled>Save to Corpus</button>
        <button id="btn-check" disabled>Check Pronunciation</button>
    </div>

    <div id="status"></div>
    
    <div id="transcription-box" style="margin-top: 1rem; padding: 10px; background: #f0f0f0; border-radius: 5px; display: none;">
        <strong>Transcription (Whisper):</strong> <span id="transcript-text"></span>
    </div>

    <div id="results" style="margin-top: 1rem; line-height: 2;"></div>

    <h3>Raw JSON Response</h3>
    <pre id="json-output" style="background: #eee; padding: 10px; border-radius: 5px; overflow-x: auto; font-size: 0.9em; max-height: 400px; overflow-y: scroll;"></pre>

    <script>
        let mediaRecorder;
        let audioChunks = [];
        let audioBlob = null;

        const btnRecord = document.getElementById('btn-record');
        const btnStop = document.getElementById('btn-stop');
        const btnSave = document.getElementById('btn-save');
        const btnCheck = document.getElementById('btn-check');
        const statusDiv = document.getElementById('status');
        const resultsDiv = document.getElementById('results');
        const recIndicator = document.getElementById('recording-indicator');
        const transBox = document.getElementById('transcription-box');
        const transText = document.getElementById('transcript-text');
        const jsonOutput = document.getElementById('json-output');

        btnRecord.onclick = async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                
                mediaRecorder.onstop = () => {
                    audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    btnSave.disabled = false;
                    btnCheck.disabled = false;
                    statusDiv.innerText = "Recording finished. Ready to Save or Check.";
                    recIndicator.style.display = 'none';
                };

                mediaRecorder.start();
                btnRecord.disabled = true;
                btnStop.disabled = false;
                recIndicator.style.display = 'inline';
                statusDiv.innerText = "Recording...";
            } catch (err) {
                console.error(err);
                statusDiv.innerText = "Error accessing microphone: " + err.message;
            }
        };

        btnStop.onclick = () => {
            mediaRecorder.stop();
            btnRecord.disabled = false;
            btnStop.disabled = true;
        };

        btnSave.onclick = async () => {
            if (!audioBlob) return;
            statusDiv.innerText = "Saving...";
            
            const formData = new FormData();
            formData.append('audio', audioBlob, 'recording.wav');
            formData.append('text', document.getElementById('ref-text').value);

            try {
                const res = await fetch('/save', { method: 'POST', body: formData });
                const data = await res.json();
                statusDiv.innerText = `Saved: ${data.message}`;
            } catch (err) {
                statusDiv.innerText = "Save failed: " + err.message;
            }
        };

        btnCheck.onclick = async () => {
            if (!audioBlob) return;
            statusDiv.innerText = "Checking Content & Pronunciation (ASR + MFA)... please wait 1-2 mins.";
            resultsDiv.innerHTML = "";
            transBox.style.display = 'none';
            jsonOutput.innerText = "";
            
            const formData = new FormData();
            formData.append('audio', audioBlob, 'check.wav');
            formData.append('text', document.getElementById('ref-text').value);

            try {
                const res = await fetch('/check', { method: 'POST', body: formData });
                const data = await res.json();
                
                // Print JSON immediately for debugging
                jsonOutput.innerText = JSON.stringify(data, null, 2);
                
                if (data.error) {
                    statusDiv.innerText = "Error: " + data.error;
                    return;
                }

                statusDiv.innerText = `Check Complete. Accuracy: ${(data.summary.correct / data.summary.total * 100).toFixed(1)}%`;
                
                // Show Transcript
                if (data.transcript) {
                    transBox.style.display = 'block';
                    transText.innerText = data.transcript;
                }

                // Render words
                data.words.forEach(w => {
                    const span = document.createElement('span');
                    span.innerText = w.word;
                    span.className = 'word';
                    
                    if (w.status === 'correct') {
                        span.className += ' correct';
                        if (w.stress_error) span.className += ' stress-error';
                    } else if (w.status === 'omitted') {
                        span.className += ' wrong';
                        span.style.textDecoration = 'line-through';
                        span.style.opacity = '0.7';
                    } else if (w.status === 'inserted') {
                        span.className += ' wrong';
                        span.style.backgroundColor = '#cce5ff'; // Blue-ish for insertion
                        span.style.color = '#004085';
                    } else if (w.status === 'mispronounced') {
                        span.className += ' stress-error'; // Use yellow for mispronounced
                        span.style.border = '1px solid orange';
                    }
                    
                    resultsDiv.appendChild(span);
                    resultsDiv.appendChild(document.createTextNode(" "));
                });

            } catch (err) {
                statusDiv.innerText = "Check failed: " + err.message;
            }
        };
    </script>
</body>
</html>
